// Generated by jextract

package gov.nasa.gsfc.heasarc.cfitsio;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
public class fpstate {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_LONG$LAYOUT.withName("comptype"),
        Constants$root.C_FLOAT$LAYOUT.withName("quantize_level"),
        Constants$root.C_LONG$LAYOUT.withName("no_dither"),
        Constants$root.C_LONG$LAYOUT.withName("dither_offset"),
        Constants$root.C_LONG$LAYOUT.withName("dither_method"),
        Constants$root.C_FLOAT$LAYOUT.withName("scale"),
        Constants$root.C_FLOAT$LAYOUT.withName("rescale_noise"),
        Constants$root.C_LONG$LAYOUT.withName("smooth"),
        Constants$root.C_LONG$LAYOUT.withName("int_to_float"),
        Constants$root.C_FLOAT$LAYOUT.withName("n3ratio"),
        Constants$root.C_FLOAT$LAYOUT.withName("n3min"),
        MemoryLayout.sequenceLayout(6, Constants$root.C_LONG$LAYOUT).withName("ntile"),
        Constants$root.C_LONG$LAYOUT.withName("to_stdout"),
        Constants$root.C_LONG$LAYOUT.withName("listonly"),
        Constants$root.C_LONG$LAYOUT.withName("clobber"),
        Constants$root.C_LONG$LAYOUT.withName("delete_input"),
        Constants$root.C_LONG$LAYOUT.withName("do_not_prompt"),
        Constants$root.C_LONG$LAYOUT.withName("do_checksums"),
        Constants$root.C_LONG$LAYOUT.withName("do_gzip_file"),
        Constants$root.C_LONG$LAYOUT.withName("do_images"),
        Constants$root.C_LONG$LAYOUT.withName("do_tables"),
        Constants$root.C_LONG$LAYOUT.withName("test_all"),
        Constants$root.C_LONG$LAYOUT.withName("verbose"),
        MemoryLayout.sequenceLayout(513, Constants$root.C_CHAR$LAYOUT).withName("prefix"),
        MemoryLayout.sequenceLayout(513, Constants$root.C_CHAR$LAYOUT).withName("extname"),
        MemoryLayout.paddingLayout(16),
        Constants$root.C_LONG$LAYOUT.withName("delete_suffix"),
        MemoryLayout.sequenceLayout(513, Constants$root.C_CHAR$LAYOUT).withName("outfile"),
        MemoryLayout.paddingLayout(24),
        Constants$root.C_LONG$LAYOUT.withName("firstfile"),
        Constants$root.C_LONG$LAYOUT.withName("initialized"),
        Constants$root.C_LONG$LAYOUT.withName("preflight_checked")
    );
    public static MemoryLayout $LAYOUT() {
        return fpstate.$struct$LAYOUT;
    }
    static final VarHandle comptype$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("comptype"));
    public static VarHandle comptype$VH() {
        return fpstate.comptype$VH;
    }
    public static int comptype$get(MemorySegment seg) {
        return (int)fpstate.comptype$VH.get(seg);
    }
    public static void comptype$set( MemorySegment seg, int x) {
        fpstate.comptype$VH.set(seg, x);
    }
    public static int comptype$get(MemorySegment seg, long index) {
        return (int)fpstate.comptype$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void comptype$set(MemorySegment seg, long index, int x) {
        fpstate.comptype$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle quantize_level$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("quantize_level"));
    public static VarHandle quantize_level$VH() {
        return fpstate.quantize_level$VH;
    }
    public static float quantize_level$get(MemorySegment seg) {
        return (float)fpstate.quantize_level$VH.get(seg);
    }
    public static void quantize_level$set( MemorySegment seg, float x) {
        fpstate.quantize_level$VH.set(seg, x);
    }
    public static float quantize_level$get(MemorySegment seg, long index) {
        return (float)fpstate.quantize_level$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void quantize_level$set(MemorySegment seg, long index, float x) {
        fpstate.quantize_level$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle no_dither$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("no_dither"));
    public static VarHandle no_dither$VH() {
        return fpstate.no_dither$VH;
    }
    public static int no_dither$get(MemorySegment seg) {
        return (int)fpstate.no_dither$VH.get(seg);
    }
    public static void no_dither$set( MemorySegment seg, int x) {
        fpstate.no_dither$VH.set(seg, x);
    }
    public static int no_dither$get(MemorySegment seg, long index) {
        return (int)fpstate.no_dither$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void no_dither$set(MemorySegment seg, long index, int x) {
        fpstate.no_dither$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle dither_offset$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("dither_offset"));
    public static VarHandle dither_offset$VH() {
        return fpstate.dither_offset$VH;
    }
    public static int dither_offset$get(MemorySegment seg) {
        return (int)fpstate.dither_offset$VH.get(seg);
    }
    public static void dither_offset$set( MemorySegment seg, int x) {
        fpstate.dither_offset$VH.set(seg, x);
    }
    public static int dither_offset$get(MemorySegment seg, long index) {
        return (int)fpstate.dither_offset$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void dither_offset$set(MemorySegment seg, long index, int x) {
        fpstate.dither_offset$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle dither_method$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("dither_method"));
    public static VarHandle dither_method$VH() {
        return fpstate.dither_method$VH;
    }
    public static int dither_method$get(MemorySegment seg) {
        return (int)fpstate.dither_method$VH.get(seg);
    }
    public static void dither_method$set( MemorySegment seg, int x) {
        fpstate.dither_method$VH.set(seg, x);
    }
    public static int dither_method$get(MemorySegment seg, long index) {
        return (int)fpstate.dither_method$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void dither_method$set(MemorySegment seg, long index, int x) {
        fpstate.dither_method$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle scale$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("scale"));
    public static VarHandle scale$VH() {
        return fpstate.scale$VH;
    }
    public static float scale$get(MemorySegment seg) {
        return (float)fpstate.scale$VH.get(seg);
    }
    public static void scale$set( MemorySegment seg, float x) {
        fpstate.scale$VH.set(seg, x);
    }
    public static float scale$get(MemorySegment seg, long index) {
        return (float)fpstate.scale$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void scale$set(MemorySegment seg, long index, float x) {
        fpstate.scale$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle rescale_noise$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("rescale_noise"));
    public static VarHandle rescale_noise$VH() {
        return fpstate.rescale_noise$VH;
    }
    public static float rescale_noise$get(MemorySegment seg) {
        return (float)fpstate.rescale_noise$VH.get(seg);
    }
    public static void rescale_noise$set( MemorySegment seg, float x) {
        fpstate.rescale_noise$VH.set(seg, x);
    }
    public static float rescale_noise$get(MemorySegment seg, long index) {
        return (float)fpstate.rescale_noise$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void rescale_noise$set(MemorySegment seg, long index, float x) {
        fpstate.rescale_noise$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle smooth$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("smooth"));
    public static VarHandle smooth$VH() {
        return fpstate.smooth$VH;
    }
    public static int smooth$get(MemorySegment seg) {
        return (int)fpstate.smooth$VH.get(seg);
    }
    public static void smooth$set( MemorySegment seg, int x) {
        fpstate.smooth$VH.set(seg, x);
    }
    public static int smooth$get(MemorySegment seg, long index) {
        return (int)fpstate.smooth$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void smooth$set(MemorySegment seg, long index, int x) {
        fpstate.smooth$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle int_to_float$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("int_to_float"));
    public static VarHandle int_to_float$VH() {
        return fpstate.int_to_float$VH;
    }
    public static int int_to_float$get(MemorySegment seg) {
        return (int)fpstate.int_to_float$VH.get(seg);
    }
    public static void int_to_float$set( MemorySegment seg, int x) {
        fpstate.int_to_float$VH.set(seg, x);
    }
    public static int int_to_float$get(MemorySegment seg, long index) {
        return (int)fpstate.int_to_float$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void int_to_float$set(MemorySegment seg, long index, int x) {
        fpstate.int_to_float$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle n3ratio$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("n3ratio"));
    public static VarHandle n3ratio$VH() {
        return fpstate.n3ratio$VH;
    }
    public static float n3ratio$get(MemorySegment seg) {
        return (float)fpstate.n3ratio$VH.get(seg);
    }
    public static void n3ratio$set( MemorySegment seg, float x) {
        fpstate.n3ratio$VH.set(seg, x);
    }
    public static float n3ratio$get(MemorySegment seg, long index) {
        return (float)fpstate.n3ratio$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void n3ratio$set(MemorySegment seg, long index, float x) {
        fpstate.n3ratio$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle n3min$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("n3min"));
    public static VarHandle n3min$VH() {
        return fpstate.n3min$VH;
    }
    public static float n3min$get(MemorySegment seg) {
        return (float)fpstate.n3min$VH.get(seg);
    }
    public static void n3min$set( MemorySegment seg, float x) {
        fpstate.n3min$VH.set(seg, x);
    }
    public static float n3min$get(MemorySegment seg, long index) {
        return (float)fpstate.n3min$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void n3min$set(MemorySegment seg, long index, float x) {
        fpstate.n3min$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static MemorySegment ntile$slice(MemorySegment seg) {
        return seg.asSlice(44, 24);
    }
    static final VarHandle to_stdout$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("to_stdout"));
    public static VarHandle to_stdout$VH() {
        return fpstate.to_stdout$VH;
    }
    public static int to_stdout$get(MemorySegment seg) {
        return (int)fpstate.to_stdout$VH.get(seg);
    }
    public static void to_stdout$set( MemorySegment seg, int x) {
        fpstate.to_stdout$VH.set(seg, x);
    }
    public static int to_stdout$get(MemorySegment seg, long index) {
        return (int)fpstate.to_stdout$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void to_stdout$set(MemorySegment seg, long index, int x) {
        fpstate.to_stdout$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle listonly$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("listonly"));
    public static VarHandle listonly$VH() {
        return fpstate.listonly$VH;
    }
    public static int listonly$get(MemorySegment seg) {
        return (int)fpstate.listonly$VH.get(seg);
    }
    public static void listonly$set( MemorySegment seg, int x) {
        fpstate.listonly$VH.set(seg, x);
    }
    public static int listonly$get(MemorySegment seg, long index) {
        return (int)fpstate.listonly$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void listonly$set(MemorySegment seg, long index, int x) {
        fpstate.listonly$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle clobber$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("clobber"));
    public static VarHandle clobber$VH() {
        return fpstate.clobber$VH;
    }
    public static int clobber$get(MemorySegment seg) {
        return (int)fpstate.clobber$VH.get(seg);
    }
    public static void clobber$set( MemorySegment seg, int x) {
        fpstate.clobber$VH.set(seg, x);
    }
    public static int clobber$get(MemorySegment seg, long index) {
        return (int)fpstate.clobber$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void clobber$set(MemorySegment seg, long index, int x) {
        fpstate.clobber$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle delete_input$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("delete_input"));
    public static VarHandle delete_input$VH() {
        return fpstate.delete_input$VH;
    }
    public static int delete_input$get(MemorySegment seg) {
        return (int)fpstate.delete_input$VH.get(seg);
    }
    public static void delete_input$set( MemorySegment seg, int x) {
        fpstate.delete_input$VH.set(seg, x);
    }
    public static int delete_input$get(MemorySegment seg, long index) {
        return (int)fpstate.delete_input$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void delete_input$set(MemorySegment seg, long index, int x) {
        fpstate.delete_input$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle do_not_prompt$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("do_not_prompt"));
    public static VarHandle do_not_prompt$VH() {
        return fpstate.do_not_prompt$VH;
    }
    public static int do_not_prompt$get(MemorySegment seg) {
        return (int)fpstate.do_not_prompt$VH.get(seg);
    }
    public static void do_not_prompt$set( MemorySegment seg, int x) {
        fpstate.do_not_prompt$VH.set(seg, x);
    }
    public static int do_not_prompt$get(MemorySegment seg, long index) {
        return (int)fpstate.do_not_prompt$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void do_not_prompt$set(MemorySegment seg, long index, int x) {
        fpstate.do_not_prompt$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle do_checksums$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("do_checksums"));
    public static VarHandle do_checksums$VH() {
        return fpstate.do_checksums$VH;
    }
    public static int do_checksums$get(MemorySegment seg) {
        return (int)fpstate.do_checksums$VH.get(seg);
    }
    public static void do_checksums$set( MemorySegment seg, int x) {
        fpstate.do_checksums$VH.set(seg, x);
    }
    public static int do_checksums$get(MemorySegment seg, long index) {
        return (int)fpstate.do_checksums$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void do_checksums$set(MemorySegment seg, long index, int x) {
        fpstate.do_checksums$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle do_gzip_file$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("do_gzip_file"));
    public static VarHandle do_gzip_file$VH() {
        return fpstate.do_gzip_file$VH;
    }
    public static int do_gzip_file$get(MemorySegment seg) {
        return (int)fpstate.do_gzip_file$VH.get(seg);
    }
    public static void do_gzip_file$set( MemorySegment seg, int x) {
        fpstate.do_gzip_file$VH.set(seg, x);
    }
    public static int do_gzip_file$get(MemorySegment seg, long index) {
        return (int)fpstate.do_gzip_file$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void do_gzip_file$set(MemorySegment seg, long index, int x) {
        fpstate.do_gzip_file$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle do_images$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("do_images"));
    public static VarHandle do_images$VH() {
        return fpstate.do_images$VH;
    }
    public static int do_images$get(MemorySegment seg) {
        return (int)fpstate.do_images$VH.get(seg);
    }
    public static void do_images$set( MemorySegment seg, int x) {
        fpstate.do_images$VH.set(seg, x);
    }
    public static int do_images$get(MemorySegment seg, long index) {
        return (int)fpstate.do_images$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void do_images$set(MemorySegment seg, long index, int x) {
        fpstate.do_images$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle do_tables$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("do_tables"));
    public static VarHandle do_tables$VH() {
        return fpstate.do_tables$VH;
    }
    public static int do_tables$get(MemorySegment seg) {
        return (int)fpstate.do_tables$VH.get(seg);
    }
    public static void do_tables$set( MemorySegment seg, int x) {
        fpstate.do_tables$VH.set(seg, x);
    }
    public static int do_tables$get(MemorySegment seg, long index) {
        return (int)fpstate.do_tables$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void do_tables$set(MemorySegment seg, long index, int x) {
        fpstate.do_tables$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle test_all$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("test_all"));
    public static VarHandle test_all$VH() {
        return fpstate.test_all$VH;
    }
    public static int test_all$get(MemorySegment seg) {
        return (int)fpstate.test_all$VH.get(seg);
    }
    public static void test_all$set( MemorySegment seg, int x) {
        fpstate.test_all$VH.set(seg, x);
    }
    public static int test_all$get(MemorySegment seg, long index) {
        return (int)fpstate.test_all$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void test_all$set(MemorySegment seg, long index, int x) {
        fpstate.test_all$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle verbose$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("verbose"));
    public static VarHandle verbose$VH() {
        return fpstate.verbose$VH;
    }
    public static int verbose$get(MemorySegment seg) {
        return (int)fpstate.verbose$VH.get(seg);
    }
    public static void verbose$set( MemorySegment seg, int x) {
        fpstate.verbose$VH.set(seg, x);
    }
    public static int verbose$get(MemorySegment seg, long index) {
        return (int)fpstate.verbose$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void verbose$set(MemorySegment seg, long index, int x) {
        fpstate.verbose$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static MemorySegment prefix$slice(MemorySegment seg) {
        return seg.asSlice(112, 513);
    }
    public static MemorySegment extname$slice(MemorySegment seg) {
        return seg.asSlice(625, 513);
    }
    static final VarHandle delete_suffix$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("delete_suffix"));
    public static VarHandle delete_suffix$VH() {
        return fpstate.delete_suffix$VH;
    }
    public static int delete_suffix$get(MemorySegment seg) {
        return (int)fpstate.delete_suffix$VH.get(seg);
    }
    public static void delete_suffix$set( MemorySegment seg, int x) {
        fpstate.delete_suffix$VH.set(seg, x);
    }
    public static int delete_suffix$get(MemorySegment seg, long index) {
        return (int)fpstate.delete_suffix$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void delete_suffix$set(MemorySegment seg, long index, int x) {
        fpstate.delete_suffix$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static MemorySegment outfile$slice(MemorySegment seg) {
        return seg.asSlice(1144, 513);
    }
    static final VarHandle firstfile$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("firstfile"));
    public static VarHandle firstfile$VH() {
        return fpstate.firstfile$VH;
    }
    public static int firstfile$get(MemorySegment seg) {
        return (int)fpstate.firstfile$VH.get(seg);
    }
    public static void firstfile$set( MemorySegment seg, int x) {
        fpstate.firstfile$VH.set(seg, x);
    }
    public static int firstfile$get(MemorySegment seg, long index) {
        return (int)fpstate.firstfile$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void firstfile$set(MemorySegment seg, long index, int x) {
        fpstate.firstfile$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle initialized$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("initialized"));
    public static VarHandle initialized$VH() {
        return fpstate.initialized$VH;
    }
    public static int initialized$get(MemorySegment seg) {
        return (int)fpstate.initialized$VH.get(seg);
    }
    public static void initialized$set( MemorySegment seg, int x) {
        fpstate.initialized$VH.set(seg, x);
    }
    public static int initialized$get(MemorySegment seg, long index) {
        return (int)fpstate.initialized$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void initialized$set(MemorySegment seg, long index, int x) {
        fpstate.initialized$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle preflight_checked$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("preflight_checked"));
    public static VarHandle preflight_checked$VH() {
        return fpstate.preflight_checked$VH;
    }
    public static int preflight_checked$get(MemorySegment seg) {
        return (int)fpstate.preflight_checked$VH.get(seg);
    }
    public static void preflight_checked$set( MemorySegment seg, int x) {
        fpstate.preflight_checked$VH.set(seg, x);
    }
    public static int preflight_checked$get(MemorySegment seg, long index) {
        return (int)fpstate.preflight_checked$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void preflight_checked$set(MemorySegment seg, long index, int x) {
        fpstate.preflight_checked$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }
}


